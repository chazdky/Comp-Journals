\documentclass[../CIT288SecurityResearchNotebook.tex]{subfiles}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter[Research Ch. 03]{Research\linebreak[1] Chapter 03 \hspace*{\fill}{\date}}
\noindent\textbf{{Network Security} \hspace*{\fill}{\textbf{CIT 288}}}\linebreak[1]
{{Spring 2020} \hspace*{\fill}{Chaz Davis}}                             
%===================================


\mysection{Question}{\bf{An early attempt to force users to use less predictable passwords involved computer-supplied passwords.  The passwords were eight characters long and were taken from the character set consisting of lowercase letters and digits. They were generated by a pseudorandom number generator with ${2}^{15}$ possible starting values. Using the technology of the time, the time required to search through all character strings of length 8 from a 36-character alphabet was 112 years. Unfortunately, this is not a true reflection of the actual security of the system. Explain the problem.
}}

\mysubsection{1}{answer}
Analyze the actual security of the computer supplied passwords: In the early days to select strong passwords, the computers use a psuedo random number generator to generate passwords which are 8 characters in lengths using 36 character alphabets.  the number of possible strings that can be generated using 36 characters with a length of eight characters is ${36}^{8}$  which is aproximately equal to ${2}^{41}$ But the psudorandom generator can produce ${2}^{15}$ passwords. as a result, the number of passwords that needs to be looked at to hack is only ${2}^{15}$.  Therefore, this system does not provide much security.



\mysection{Question}{\bf{A phonetic password generator picks two segments randomly for each six-letter password. The form of each segment is CVC (consonant, vowel, consonant), where V = < a, e, i, o, u >  and C = V .  What is the total password population? What is the probability of an adversary guessing a password correctly?
}} 

\mysubsection{1}{part a: answer}
the password generator generates 6 letter passwords randomly which consist of two segments. the segment is 
\begin{itemize}
	\item{The segment} is of the form CVC (consonant, vowel, consonant) 
		\subitem{Vowels} consist of 5 letters
		\subitem{Consonants} consist of 21 letters
	\item{6 letters} the 6 letter password is of the form CVCCVC
\item{The total number} of passwords that a phoetic password generator can generate is ${21x5x21x21x5x21}$ which is equal to: 4,862,025.
\end{itemize}

\mysubsection{2}{part b: answer}
The probability to guess a password correctly is calulated using the following formula:
\hspace{0.2cm}
\begin{tcolorbox}[width=6.3in] 
  \begin{equation}
	  \text{Probability of correct number of guesses =} \frac{1}{\text{Total password population}} 
  \end{equation}
\end{tcolorbox}
\hspace{0.2cm}
Here, the total password population is 4,862,025; substitute it in the above formula to find the probability.
\hspace{0.2cm}
\begin{tcolorbox}[width=6.3in] 
	\begin{equation}
\text{Probability of correct password guesses} = \frac{1}{4,862,025} \approx {2}x{10}^{-7}
	\end{equation}
\end{tcolorbox}
\hspace{0.2cm}

\hspace{0.2cm}
\begin{tcolorbox}[width=6.3in] 
	\begin{equation}
		\text{So, the probability to guess a correct password by an adversay is approximately equal to } {2}x{10}^{-7}
	\end{equation}
\end{tcolorbox}
\hspace{0.2cm}


\mysection{Question}{\bf{It was stated that the inclusion of the salt in the UNIX password scheme increases the difficulty of guessing by a factor of 4096. But the salt is stored in plaintext in the same entry as the corresponding ciphertext password. Therefore, those two characters are known to the attacker and need not be guessed. Why is it asserted that the salt increases security?
}}
\mysubsection{1}{answer}
{\bf{Salt: }} An extensively employed password security is the usage of a salt value
and hashed passwords. This password scheme is found on all UNIX systems as weall as on
other operating systems.
\hspace{0.2cm}
\begin{tcolorbox}[width=6.3in]
{\bf{the salt has certain features that increase the security of the password scheme}}
  \begin{outline}
  \1 Different salt values for the same password 
    \2 Salt averts duplicate passwords in the password file
    \2 Even when two end-users pick the same password, those passwords will be given different salt values.
    \2 For this reason, the hashed password of the two end-users will be different
  \1 Increase the difficulty of guessing a pasword
    \2 Salt significantly increases the difficulty of dictionary attacks
    \2 If salt is of ``b'' bit length, then the number of possible passwords is
    amplified by a factor of ``$2^b$''.
  \end{outline}
\end{tcolorbox}
\hspace{0.2cm}
So, for those reasons, it is understood that the salt increases security

\mysection{Question}{\bf{Assuming you have successfully answered the preceding problem and understand the significance of the salt, here is another section. Wouldn’t it be possible to thwart completely all password crackers by dramatically increasing the salt size to, say, 24 or 48 bits?
}}

\mysubsection{1}{answer}
Protecting the security of the system completely from password crackers does not depend
on the salt size but depends on the user population size. Using the hash function of
the cipher password and the randomly generated salt and both are stored in the password
file. Increasing the size of salt leads to resolve problems of two users having the
same salt. {\emph{Because, if the salt is the same for more users then the attacker
needs to do seperate encryptions for each password of the user}} So, increasing the sie
of salt through bits, such as 24 or 48, does not protect the security of the system
completely from all password crackers.

\mysection{Question}{\bf{A relatively new authentication proposal is the Secure Quick Reliable Login (SQRL) described here:
\url{https://www.grc.com/sqrl/sqrl.htm}. Write a brief summary of how SQRL works and indicate how it fits into the categories of types of user authentication listed in this chapter.
}}

\mysubsection{1}{answer}
SQRL logs into websites for you. instead of using a username, email, and password, SQRL
uses an app to login to SQRL aware sites. When it logs you in it uses a long string of
code that looks like: E6Qs2gX7W-Pwi9Y3KAmbkuYjLSWXCtKyBcymWIoHAuo
\hfill \break
Your SQRL identity is different for every websitem but its always the same long code
for each individual website that you've visited before. this means that websites never
know who you are, but they do know when ``You'` return.

It seems to me that it is almost like anEncrypted API that acts as a multi factor
authentication, but as a single factor authentication. very interesting, and even
stores data from the websites within its own crypt instead of letting that data be
stored on websites where breaches and such happen. ill be very insterested to see where
they go with this, it took 6 years for steve to get it out from the first time he
talked about it. and it just came out. but already is getting traction with Os's and
Websites alike. and has a setup for shared use authenticator, for sites like netflix,
where several people can all login to the same account each from their own setup, but
all as the same Netflix account identity.


\mysection{Question}{\bf{In general terms, what are four means of authenticating a user’s identity?
}}

\mysubsection{1}{answer}

\begin{outline}
  \1 Something the individual {\bf{knows}}:
    \2 a password
    \2 a Personal Identification Number (PIN)
    \2 answers to prearranged questions
  \1 Something the individual {\bf{possesses}} (these are known as tokens):
    \2 Electronic key-cards
    \2 smart cards
    \2 physical keys
  \1 Something the individual {\bf{is}}(static biometrics):
    \2 Fingerprint
    \2 retina
    \2 face
  \1 Something the individual {\bf{does}}(dynamic biometrics):
    \2 voice recognition
    \2 handwriting characteristics
    \2 typing rhythm
\end{outline}


\mysection{Question}{\bf{What are two common techniques used to protect a password file?
}}

\mysubsection{1}{answer}
\begin{outline}
  \1 {\bf{Using a salt}} this is stored in plain text with the hash from (salt + password)
  \1 {\bf{Password File Access Control}} The hashed passwords are kept in a seperate file from the user IDs refferred to as shadow password file. Only priveledged users have access to this file.
\end{outline}

\mysection{Question}{\bf{Explain the difference between a simple memory card and a smart card.
}}

\mysubsection{1}{answer}
\begin{outline}
  \1 {\bf{Memory Card}} stores but does not process data
  \1 {\bf{Smart Card}} Has a micrprocessor, different types of memory, I/O ports, etc. May also have a cryptocoproccessor and an embedded antenna.
\end{outline}

\mysection{Question}{\bf{Define the terms false match rate and false nonmatch rate, and explain the use of a threshold in relationship to these two rates.
}}

\mysubsection{1}{answer}
\begin{outline}
  \1 {\bf{False Match Rate}} It measures the percent of invalid inputs which are incorrectly accepted.
  \1 {\bf{False Non Match Rate}} It measures the percent of valid inputs which are incorrectly rejected.
\end{outline}
By moving the threshhold, the probabilities can be altered but note that a decrease in false match rate doesn't necessarily result in an increase in false non-match rates, and vice versa

\mysection{Question}{\bf{Describe the general concept of a challenge-response protocol.
}}

\mysubsection{1}{answer}
The host generates a random number r and returns it to the user (=challenge). In
addition, the host specifies two functions, a hash function h() and another f() to be
used in the respomse. The user calculates $f(r', h(P'))$, where r' = r and P' is the
user's Password. When the response arrives, the host compares the incoming result to
the calculated $f(r, h(P))$ and if it matches the user is authenticated. Advantages:
Only  the hashes of the passwords have to be stored and they do not have to be
transmitted directly, so it cannot be captured during transmission.

\mysection{bonus data}
\begin{outline}
  \1 Linux Encryption Method
    \2 12-bit salt to mod DES into one way hash
    \2 zero value repeated 25 times
    \2 output translated into 11 character sequence
\end{outline}

\end{document}

